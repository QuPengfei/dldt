/*
// Copyright (c) 2018 Intel Corporation
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//      http://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
*/

#include <gflags/gflags.h>
#include <functional>
#include <iostream>
#include <fstream>
#include <random>
#include <string>
#include <memory>
#include <vector>
#include <time.h>
#include <limits>
#include <chrono>
#include <algorithm>

#include <format_reader_ptr.h>
#include <inference_engine.hpp>
#include <ext_list.hpp>

#include <samples/common.hpp>
#include <samples/slog.hpp>
#include <samples/args_helper.hpp>
#include "object_detection_sample_ssd.h"
#include <ie_api_c.h>

bool ParseAndCheckCommandLine(int argc, char *argv[])
{
    // ---------------------------Parsing and validation of input args--------------------------------------
    slog::info << "Parsing input parameters" << slog::endl;

    gflags::ParseCommandLineNonHelpFlags(&argc, &argv, true);
    if (FLAGS_h) {
        showUsage();
        return false;
    }

    if (FLAGS_ni < 1) {
        throw std::logic_error("Parameter -ni should be greater than 0 (default: 1)");
    }

    if (FLAGS_i.empty()) {
        throw std::logic_error("Parameter -i is not set");
    }

    if (FLAGS_m.empty()) {
        throw std::logic_error("Parameter -m is not set");
    }

    return true;
}

/**
* \brief The entry point for the Inference Engine object_detection sample application with C API
* \file object_detection_sample_ssd_c/main.cpp
* \example object_detection_sample_ssd_c/main.cpp
*/
int main(int argc, char *argv[])
{

    IEConfig config;
    IEImageSize imageSize;

    IEInputOutputInfo *info;

    IEData image;
    void *context = NULL;
    float *resultPtr = NULL;

    char pluginPath[] = "../../../lib/intel64";

    int i = 0;
    int batchSize = 1;

    memset(&config, 0, sizeof(IEConfig));
    memset(&imageSize, 0, sizeof(IEImageSize));
    memset(&image, 0, sizeof(IEData));

    // -------------------------------Create the context--------------------------------------------------------
    context = IEAllocateContext();
    slog::info << "IE context: " << context << "\n";

    try {
        /** This sample covers certain topology and cannot be generalized for any object detection one **/

        // --------------------------- 1. Parsing and validation of input args ---------------------------------
        if (!ParseAndCheckCommandLine(argc, argv)) {
            return 0;
        }
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 2. Read input -----------------------------------------------------------
        /** This vector stores paths to the processed images **/
        std::vector < std::string > images;
        parseInputFilesArguments(images);
        if (images.empty())
            throw std::logic_error("No suitable images were found");
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 3. Load Plugin for inference engine -------------------------------------
        slog::info << "Loading plugin" << slog::endl;
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 4. Read IR Generated by ModelOptimizer (.xml and .bin files) ------------
        std::string binFileName = fileNameNoExt(FLAGS_m) + ".bin";
        char *xmlfile = &FLAGS_m[0];
        slog::info << "Loading network files:" "\n\t" << FLAGS_m << "\n\t" << binFileName << "\n\t" << xmlfile << slog::endl;

        config.pluginPath = pluginPath;
        config.modelFileName = xmlfile;
        config.cpuExtPath = NULL;
        config.cldnnExtPath = NULL;
        config.perfCounter = 0;
        config.targetId = IE_CPU;

        if (FLAGS_d.find("GPU") != std::string::npos)
            config.targetId = IE_GPU;
        else if (FLAGS_d.find("MYRIAD") != std::string::npos)
            config.targetId = IE_MYRIAD;
        else if (FLAGS_d.find("FPGA") != std::string::npos)
            config.targetId = IE_FPGA;

        if (!FLAGS_l.empty())
            config.cpuExtPath = &FLAGS_l[0];
        if (!FLAGS_c.empty())
            config.cldnnExtPath = &FLAGS_c[0];
        if (FLAGS_pc)
            config.perfCounter = 1;

        IELoadModel(context, &config);
        IEAllocateInputOutputInfo(context, &config);
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 5. Prepare input blobs --------------------------------------------------
        slog::info << "Preparing input blobs" << slog::endl;

        info = &config.inputInfos;
        IEGetInputInfo(context, info);

        /** SSD network has one input and one output **/
        if (info->numbers != 1 && info->numbers != 2)
            throw std::logic_error("Sample supports topologies only with 1 or 2 inputs");
        info->tensor[0].precision = IE_U8;
        info->tensor[0].dataType = IE_DATA_TYPE_IMG;

        slog::info << "Input size: " << info->numbers << slog::endl;

        for (i = 0; i < info->numbers; i++) {
            if (info->tensor[i].rank == 4) {
                info->tensor[i].precision = IE_U8;
                info->tensor[i].dataType = IE_DATA_TYPE_IMG;
            } else if (info->tensor[i].rank == 2) {
                info->tensor[i].precision = IE_FP32;
                info->tensor[i].dataType = IE_DATA_TYPE_NON_IMG;
            }
            slog::info << "Id,Rank " << i << " ," << info->tensor[i].rank << "[" << info->tensor[i].dim[0] << " X " << info->tensor[i].dim[1] << " X " << info->tensor[i].dim[2] << " X " << info->tensor[i].dim[3] << "]" << "[" << info->tensor[i].precision << " X " <<
                info->tensor[i].layout << " X " << info->tensor[i].dataType << "]" << info->batchSize << slog::endl;
        }

        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 6. Prepare output blobs -------------------------------------------------
        slog::info << "Preparing output blobs" << slog::endl;

        info = &config.outputInfos;
        IEGetOutputInfo(context, info);

        slog::info << "Output size: " << info->numbers << slog::endl;

        for (i = 0; i < info->numbers; i++) {
            slog::info << "Id,Rank " << i << " ," << info->tensor[i] .rank << "[" << info->tensor[i].dim[0] << " X " << info->tensor[i].dim[1] << " X " << info->tensor[i].dim[2] << " X " << info->tensor[i].dim[3] << "]" << "[" << info->tensor[i].precision << " X " <<
                info->tensor[i].layout << " X " << info->tensor[i].dataType << "]" << info->batchSize << slog::endl;
        }

        unsigned int maxProposalCount = info->tensor[0].dim[2];
        unsigned int objectSize = info->tensor[0].dim[3];
        if (objectSize != 7) {
            throw std::logic_error("Output should have 7 as a last dimension");
        }
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 7. Loading model to the plugin ------------------------------------------
        slog::info << "Loading model to the plugin" << slog::endl;
        IECreateModel(context, &config);
        IEGetInputImageSize(context, &imageSize);
        slog::info << "IE model image size: " << imageSize.width << "X" << imageSize.height << slog::endl;
        // -----------------------------------------------------------------------------------------------------

        // --------------------------- 8. Create infer request -------------------------------------------------
        // -----------------------------------------------------------------------------------------------------
        // --------------------------- 9. Prepare input --------------------------------------------------------
        /** Collect images data ptrs **/
        std::vector < int >imageWidths, imageHeights;
        std::vector < std::shared_ptr < unsigned char >>imagesData, originalImagesData;
        for (auto & i:images) {
            FormatReader::ReaderPtr reader(i.c_str());
            if (reader.get() == nullptr) {
                slog::warn << "Image " + i + " cannot be read!" << slog::endl;
                continue;
            }
            /** Store image data **/
            std::shared_ptr < unsigned char >originalData(reader->getData());
            std::shared_ptr < unsigned char >data(reader->getData(imageSize.width, imageSize.height));
            if (data.get() != nullptr) {
                originalImagesData.push_back(originalData);
                imagesData.push_back(data);
                imageWidths.push_back(reader->width());
                imageHeights.push_back(reader->height());

                image.tensor.dim[0] = imageSize.width;
                image.tensor.dim[1] = imageSize.height;
                image.tensor.dimStride[0] = imageSize.width;
                image.tensor.dimStride[1] = imageSize.height;
                image.tensor.dim[2] = 3;
                image.tensor.rank = 3;
                image.batchIdx = 0;
                image.header.bufSize = reader->size();
                image.header.bufId = (uintptr_t)data.get();
                image.tensor.precision = IE_U8;
                image.tensor.dataType = IE_DATA_TYPE_IMG;
                image.imageFormat = IE_IMAGE_BGR_PACKED;

                IESetInput(context, 0, &image);
            }
        }

        if (imagesData.empty())
            throw std::logic_error("Valid input images were not found!");

        // -----------------------------------------------------------------------------------------------------
        // --------------------------- 10. Do inference ---------------------------------------------------------
        slog::info << "Start inference (" << FLAGS_ni << " iterations)" << slog::endl;

        typedef std::chrono::high_resolution_clock Time;
        typedef std::chrono::duration < double, std::ratio < 1, 1000 >> ms;
        typedef std::chrono::duration < float >fsec;

        double total = 0.0;
        /** Start inference & calc performance **/
        for (int iter = 0; iter < FLAGS_ni; ++iter) {
            auto t0 = Time::now();
            IEForward(context, IE_INFER_MODE_SYNC);
            auto t1 = Time::now();
            fsec fs = t1 - t0;
            ms d = std::chrono::duration_cast < ms > (fs);
            total += d.count();
        }
        // -----------------------------------------------------------------------------------------------------
        // --------------------------- 11. Process output -------------------------------------------------------
        slog::info << "Processing output blobs" << slog::endl;

        unsigned int size = 0;

        const float *detection = (float *) IEGetResult(context, 0, &size);

        std::vector < std::vector < int >>boxes(batchSize);
        std::vector < std::vector < int >>classes(batchSize);

        /* Each detection has image_id that denotes processed image */
        for (int curProposal = 0; curProposal < maxProposalCount; curProposal++) {
            float image_id = detection[curProposal * objectSize + 0];
            float label = detection[curProposal * objectSize + 1];
            float confidence = detection[curProposal * objectSize + 2];
            /* CPU and GPU plugins have difference in DetectionOutput layer, so we need both checks */
            if (image_id < 0 || confidence == 0) {
                continue;
            }

            float xmin = detection[curProposal * objectSize + 3] * imageWidths[image_id];
            float ymin = detection[curProposal * objectSize + 4] * imageHeights[image_id];
            float xmax = detection[curProposal * objectSize + 5] * imageWidths[image_id];
            float ymax = detection[curProposal * objectSize + 6] * imageHeights[image_id];

            std::cout << "[" << curProposal << "," << label <<
                "] element, prob = " << confidence << "    (" << xmin << "," << ymin << ")-(" << xmax << "," << ymax << ")" << " batch id : " << image_id;

            if (confidence > 0.5) {
            /** Drawing only objects with >50% probability **/
                classes[image_id].push_back(static_cast < int >(label));
                boxes[image_id].push_back(static_cast < int >(xmin));
                boxes[image_id].push_back(static_cast < int >(ymin));
                boxes[image_id].push_back(static_cast < int >(xmax - xmin));
                boxes[image_id].push_back(static_cast < int >(ymax - ymin));
                std::cout << " WILL BE PRINTED!";
            }
            std::cout << std::endl;
        }

        for (size_t batch_id = 0; batch_id < batchSize; ++batch_id) {
            addRectangles(originalImagesData[batch_id].get(), imageHeights[batch_id], imageWidths[batch_id], boxes[batch_id], classes[batch_id]);
            const std::string image_path = "out_" + std::to_string(batch_id) + ".bmp";
            if (writeOutputBmp(image_path, originalImagesData[batch_id].get(), imageHeights[batch_id], imageWidths[batch_id])) {
                slog::info << "Image " + image_path + " created!" << slog::endl;
            } else {
                throw std::logic_error(std::string("Can't create a file: ") + image_path);
            }
        }
        // -----------------------------------------------------------------------------------------------------
        std::cout << std::endl << "total inference time: " << total << std::endl;
        std::cout << "Average running time of one iteration: " << total / static_cast < double >(FLAGS_ni) << " ms" << std::endl;
        std::cout << std::endl << "Throughput: " << 1000 * static_cast < double >(FLAGS_ni) * batchSize / total << " FPS" << std::endl;
        std::cout << std::endl;

        /** Show performance results **/
        if (FLAGS_pc) {
            IEPrintLog(context, IE_LOG_LEVEL_ENGINE);
        }
    }
    catch(const std::exception & error) {
        slog::err << error.what() << slog::endl;
        return 1;
    }
    catch( ...) {
        slog::err << "Unknown/internal exception happened." << slog::endl;
        return 1;
    }

    IEFreeContext(context,&config);
    slog::info << "Execution successful" << slog::endl;
    return 0;
}